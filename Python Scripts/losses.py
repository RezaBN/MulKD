{"cells":[{"cell_type":"code","source":["# losses.py\n","\"\"\"\n","This file contains the custom loss components for Contrastive Representation\n","Distillation (CRD), including the projection head and the NCE-based loss.\n","\"\"\"\n","\n","import torch\n","import torch.nn as nn\n","import torch.nn.functional as F\n","\n","from config import DEVICE\n","\n","class CRDProjectionHead(nn.Module):\n","    \"\"\"\n","    A projection head used in CRD to map features to a lower-dimensional space\n","    where the contrastive loss is calculated.\n","    \"\"\"\n","    def __init__(self, input_dim, output_dim=128):\n","        super(CRDProjectionHead, self).__init__()\n","        # Define a hidden dimension, which is a common practice in projection heads\n","        hidden_dim = output_dim\n","        if input_dim > 0:\n","            hidden_dim = max(output_dim, input_dim // 2)\n","        else:\n","            print(f\"Warning: CRDProjectionHead received input_dim <= 0 ({input_dim}). Defaulting.\")\n","            input_dim = output_dim\n","            hidden_dim = output_dim\n","\n","        self.fc1 = nn.Linear(input_dim, hidden_dim)\n","        self.relu = nn.ReLU(inplace=True)\n","        self.fc2 = nn.Linear(hidden_dim, output_dim)\n","\n","    def forward(self, x):\n","        x = self.relu(self.fc1(x))\n","        x = self.fc2(x)\n","        # L2-normalize the output features\n","        return F.normalize(x, p=2, dim=1)\n","\n","\n","class NCELoss(nn.Module):\n","    \"\"\"\n","    Noise-Contrastive Estimation Loss. This implementation uses in-batch negatives.\n","    It encourages the features of a student-teacher pair (positive pair) to be more\n","    similar than features of a student and other teachers in the batch (negative pairs).\n","    \"\"\"\n","    def __init__(self, temperature, num_negative_samples_config):\n","        super(NCELoss, self).__init__()\n","        self.temperature = temperature\n","        # The number of negative samples is implicitly defined by the batch size in this implementation.\n","        # self.num_negative_samples = num_negative_samples_config\n","\n","    def forward(self, feat_s, feat_t):\n","        batch_size = feat_s.shape[0]\n","\n","        # Positive pairs: cosine similarity between corresponding student and teacher features\n","        l_pos = torch.einsum('nc,nc->n', [feat_s, feat_t]).unsqueeze(-1)  # Shape: [B, 1]\n","\n","        # Negative pairs: cosine similarity of each student feature with all teacher features in the batch\n","        l_neg_all_pairs = torch.einsum('nc,kc->nk', [feat_s, feat_t])  # Shape: [B, B]\n","\n","        # Mask to exclude the positive pairs (diagonal) from the negative pairs\n","        mask = torch.eye(batch_size, dtype=torch.bool).to(DEVICE)\n","        l_neg = l_neg_all_pairs.masked_fill(mask, -float('inf'))\n","\n","        # Concatenate positive and negative logits\n","        logits = torch.cat([l_pos, l_neg], dim=1) / self.temperature\n","\n","        # The target label is always 0, as the positive logit is the first one\n","        labels = torch.zeros(batch_size, dtype=torch.long).to(DEVICE)\n","\n","        return F.cross_entropy(logits, labels)\n","\n","\n","class CRDLoss(nn.Module):\n","    \"\"\"\n","    Contrastive Representation Distillation (CRD) loss module.\n","    This module contains projection heads for both student and teacher features\n","    and computes the NCE loss between the projected features.\n","    \"\"\"\n","    def __init__(self, opt_crd_params):\n","        super(CRDLoss, self).__init__()\n","        self.embed_s = CRDProjectionHead(input_dim=opt_crd_params.s_dim, output_dim=opt_crd_params.feat_dim)\n","        self.embed_t = CRDProjectionHead(input_dim=opt_crd_params.t_dim, output_dim=opt_crd_params.feat_dim)\n","        self.criterion = NCELoss(opt_crd_params.nce_t, opt_crd_params.nce_n)\n","\n","    def forward(self, f_s, f_t):\n","        \"\"\"\n","        Calculates the CRD loss.\n","        f_s: student features\n","        f_t: teacher features\n","        \"\"\"\n","        # Project features into the contrastive space\n","        f_s_projected = self.embed_s(f_s)\n","        f_t_projected = self.embed_t(f_t)\n","\n","        # Calculate NCE loss. Teacher features are detached to prevent gradients from flowing back to the teacher.\n","        loss = self.criterion(f_s_projected, f_t_projected.detach())\n","        return loss"],"outputs":[],"execution_count":null,"metadata":{"id":"9jpzCzvFB8lh"}}],"metadata":{"colab":{"provenance":[]},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}